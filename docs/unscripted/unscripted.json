{"name":"unscripted","qualifiedName":"unscripted/unscripted","comment":"<p>Design command line interfaces through normal programming interfaces\nannotated with command line specific metadata.</p>","variables":{},"functions":{"setters":{},"getters":{},"constructors":{},"operators":{},"methods":{"declare":{"name":"declare","qualifiedName":"unscripted/unscripted.declare","comment":"<p>Declares a <a>unscripted/unscripted.Script</a> from <a>unscripted/unscripted.declare.model</a>.</p>\n<p>The model is generally a closure of a method, which is annotated with\ncommand-line metadata.  The model can also be a class (see below).</p>\n<p>The method itself can be annotated as a <a>unscripted/unscripted.Command</a>.</p>\n<p>The method's parameters define the script's command-line parameters.\nNamed parameters with <a>dart-core.bool</a> type or <a>unscripted/unscripted.Flag</a> metadata represent command-line\nflags.  Other named parameters represent value-taking command-line options,\nand can accept <a>unscripted/unscripted.Option</a> metadata.  Required positional parameters are\nmapped to positional command-line parameters, and can use <a>unscripted/unscripted.Positional</a> metadata.\nOptional positional parameters are not allowed.  However, <a>unscripted/unscripted.Rest</a> metadata\ncan be placed on the last positional parameter to represent all remaining\npositional arguments passed to the script.</p>\n<p>Any value-taking argument (option, positional, rest) can have a \"parser\".\nThis is a function which is responsible for validating and/or transforming\nthe string value passed on the command-line before it is passed to the\nmethod.  Rest parsers are applied to each command-line value they receive.\nIf a parser throws an exception, it is <code>toString</code>ed and displayed to the\nuser\nParsers can be declared either via the <code>parser</code> field of the\nappropriate metadata (see above), or by giving the method parameter a type\nwhich has a static <code>parse</code> method that can be used as the parser.  For\nexample <code>int</code> parameters are parsed with <code>int.parse</code>.</p>\n<p>Sub-commands can be added to the script by creating a class with instance\nmethods annotated as <a>unscripted/unscripted.SubCommand</a>s.  The model returns an instance of this\nclass and documents this in it's return type.  Most commonly the model is\na constructor of this class.  But since dart does\n<a href=\"http://dartbug.com/10659\">not yet</a> have syntax for closurizing constructors,\nthe model can be a class literal, to indicate to that the unnamed\nconstructor of the class is the actual model.</p>\n<p>Help flags ('--help' / '-h') are automatically included.  If the script has\nsub-commands, a 'help' command is also included, which can be invoked bare,\n'help' as a synonym for '--help', or by specifying a sub-command e.g.\n'help sub-command'.</p>\n<p>When the returned script is [executed][Script.execute], if the user\nrequested help for, or incorrectly invoked, the command or a sub-command,\nthen the help text is displayed, along with any specific error.  Otherwise,\nthe command-line arguments are valid, and are injected into the\ncorresponding method parameters.  If the model has sub-commands, then if a\nsub-command was specified on the command-line, it is invoked with it's\ncorresponding command-line arguments, and so forth (recursively).  If a\nmodel has sub-commands, but no sub-command was specified, this is treated\nas an error, and the help text is displayed.</p>\n<p>Basic example:</p>\n<pre><code>main(arguments) =&gt; declare(greet).execute(arguments);\n\n// Optional command-line metadata:\n@Command(help: 'Outputs a greeting')\n@ArgExample('--salutation Welcome --exclaim Bob', help: 'enthusiastic')\ngreet(\n    @Rest(help: \"Name(s) to greet\")\n    List&lt;String&gt; who, // A rest parameter, must be last positional.\n    {String salutation : 'Hello', // An option, use `@Option(...)` for metadata.\n     bool exclaim : false}) { // A flag, use `@Flag(...)` for metadata.\n\n  print('$salutation ${who.join(' ')}${exclaim ? '!' : ''}');\n\n}\n</code></pre>\n<p>Sub-command example:</p>\n<pre><code>main(arguments) =&gt; declare(Server).execute(arguments);\n\nclass Server {\n\n  final String configPath;\n\n  @Command(help: 'Manages a server')\n  Server({this.configPath: 'config.xml'});\n\n  @SubCommand(help: 'Start the server')\n  start({bool clean}) {\n    print('''\nStarting the server.\nConfig path: $configPath''');\n  }\n\n  @SubCommand(help: 'Stop the server')\n  stop() {\n    print('Stopping the server.');\n  }\n\n}\n</code></pre>\n<p>Commands and SubCommands can also be annotated with <a>unscripted/unscripted.ArgExample</a>s, to\ndocument, in the help text, example arguments that they can receive.</p>\n<p>Parameter and command names which are camelCased are mapped to their\ndash-erized command-line equivalents.  For example, <code>fooBar</code> would map to\n<code>foo-bar</code>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unscripted/unscripted.Script","inner":[]}],"parameters":{"model":{"name":"model","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]}}},"classes":{"class":[{"name":"Output","qualifiedName":"unscripted/unscripted.Output","preview":"<p>Represents a script output, either <a>unscripted/dart-io.stdout</a> or a file.</p>"},{"name":"Input","qualifiedName":"unscripted/unscripted.Input","preview":"<p>Represents a script input, either <a>unscripted/dart-io.stdin</a> or a file.</p>"},{"name":"CallStyle","qualifiedName":"unscripted/unscripted.CallStyle","preview":"<p>How the command is called on the command line.</p>"},{"name":"SubCommand","qualifiedName":"unscripted/unscripted.SubCommand","preview":"<p>An annotation which marks an instance method of a <a>unscripted/unscripted.Command</a> as a\nsub-command.</p>"},{"name":"Command","qualifiedName":"unscripted/unscripted.Command","preview":"<p>An annotation which marks a class as representing a script command.</p>"},{"name":"Rest","qualifiedName":"unscripted/unscripted.Rest","preview":"<p>An annotation which marks the last positional parameter of a method\nas a rest argument.  If the parameter has a type annotation,\nit should be <code>List</code> or <code>List&lt;String&gt;</code>.</p>"},{"name":"Positional","qualifiedName":"unscripted/unscripted.Positional","preview":"<p>An annotation which marks required positional parameters as\npositional command line parameters.</p>"},{"name":"ArgExample","qualifiedName":"unscripted/unscripted.ArgExample","preview":"<p>An annotation which gives example arguments that can be passed to a\n<a>unscripted/unscripted.Command</a> or <a>unscripted/unscripted.SubCommand</a>.</p>"},{"name":"Flag","qualifiedName":"unscripted/unscripted.Flag","preview":"<p>An annotation which marks named method parameters as command line flags.</p>"},{"name":"Option","qualifiedName":"unscripted/unscripted.Option","preview":"<p>An annotation which marks named method parameters as command line options.</p>"},{"name":"Script","qualifiedName":"unscripted/unscripted.Script","preview":"<p>Represents a command-line script.</p>"}],"typedef":{},"error":[]},"packageName":"unscripted","packageIntro":"<h1>unscripted</h1>\n<p><a href=\"https://drone.io/github.com/seaneagan/unscripted/latest\">!<a href=\"https://drone.io/github.com/seaneagan/unscripted/status.png\">Build Status</a></a></p>\n<p>Unscripted is a <a href=\"http://pub.dartlang.org/packages/unscripted\">pub package</a> for declarative command-line interface\nprogramming in dart.  Command-line interfaces are defined using ordinary method\nand class declarations, minimally annotated with command-line metadata.  \nReflection is used to derive the command-line interface from the declarations.  \nCommand-line arguments are automatically injected into the method or\nclass (constructor).  This removes the need for boilerplate logic to define, \nparse, validate and assign variables for command-line arguments.  Since the \ninterface is defined in code, standard refactoring, testing, etc. tools can \nbe used.</p>\n<h2>Demo</h2>\n<p><a href=\"https://github.com/seaneagan/unscripted/blob/master/example/cat.dart\">cat.dart</a> is a complete implementation of the *nix <code>cat</code> \nutility using unscripted.</p>\n<h2>Usage</h2>\n<p>(For more detailed usage, see the <a href=\"https://seaneagan.github.com/unscripted\">API docs</a>)</p>\n<p>A simple script to output a greeting:</p>\n<pre class=\"dart\"><code>import 'package:unscripted/unscripted.dart';\n\nmain(arguments) =&gt; declare(greet).execute(arguments);\n\n@Command(help: 'Outputs a greeting')\n@ArgExample('--salutation Welcome --exclaim Bob', help: 'enthusiastic')\ngreet(\n    @Rest(help: \"Name(s) to greet\")\n    List&lt;String&gt; who, // A rest parameter, must be last positional.\n    {String salutation : 'Hello', // An option, use `@Option(...)` for metadata.\n     bool exclaim : false}) { // A flag, use `@Flag(...)` for metadata.\n\n  print('$salutation ${who.join(' ')}${exclaim ? '!' : ''}');\n\n}\n</code></pre>\n<p>(Compare to a <a href=\"https://github.com/seaneagan/unscripted/tree/master/example/old_greet.dart\">traditiional version</a> of this script.)</p>\n<p>We can call this script as follows:</p>\n<pre class=\"shell\"><code>$ dart greet.dart Bob\nHello Bob\n$ dart greet.dart --salutation Welcome --exclaim Bob\nWelcome Bob!\n</code></pre>\n<h3>Automatic --help</h3>\n<p>Unscripted automatically defines and handles a --help/-h option,\nallowing for:</p>\n<pre class=\"shell\"><code>$ dart greet.dart --help\nOutputs a greeting\n\nUsage:\n\ndart greet.dart [options] WHO...\n\nOptions:\n\n-h, --help            Print this usage information.\n    --salutation      (defaults to \"Hello\")\n    --[no-]exclaim\n\nExamples:\n\ndart greet.dart --salutation Welcome --exclaim Bob # enthusiastic\n</code></pre>\n<h3>Sub-Commands</h3>\n<p>Sub-commands are also supported.  In this case the script is defined as a\nclass, whose instance methods can be annotated as sub-commands.  Assume we have\nthe following 'server.dart':</p>\n<pre class=\"dart\"><code>import 'package:unscripted/unscripted.dart';\n\nmain(arguments) =&gt; declare(Server).execute(arguments);\n\nclass Server {\n\n  final String configPath;\n\n  @Command(help: 'Manages a server')\n  Server({this.configPath: 'config.xml'});\n\n  @SubCommand(help: 'Start the server')\n  start({bool clean}) {\n    print('''\nStarting the server.\nConfig path: $configPath''');\n  }\n\n  @SubCommand(help: 'Stop the server')\n  stop() {\n    print('Stopping the server.');\n  }\n\n}\n</code></pre>\n<p>We can call this script as follows:</p>\n<pre class=\"shell\"><code>$ dart server.dart start --config-path my-config.xml --clean\nStarting the server.\nConfig path: my-config.xml\n</code></pre>\n<p>A 'help' sub-command is also added, which can be used as a synonym for '--help',\nwhich outputs all the basic help info <em>plus</em> a list of available commands:</p>\n<pre class=\"shell\"><code>$ dart server.dart help\nAvailable commands:\n\n  start\n  help\n  stop\n\nUse \"dart server.dart help [command]\" for more information about a command.\n</code></pre>\n<p>and as indicated there, sub-command help is also available:</p>\n<pre class=\"shell\"><code>$ dart server.dart help stop\nStop the server\n\nUsage:\n\ndart server.dart stop [options]\n\nOptions:\n\n-h, --help    Print this usage information.\n</code></pre>\n<p><a href=\"https://bitdeli.com/free\" title=\"Bitdeli Badge\">!<a href=\"https://d2weczhvl823v0.cloudfront.net/seaneagan/unscripted/trend.png\">Bitdeli Badge</a></a></p>"}