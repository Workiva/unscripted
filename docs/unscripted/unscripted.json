{"name":"unscripted","qualifiedName":"unscripted/unscripted","comment":"<p>Design command line interfaces through normal programming interfaces\nannotated with command line specific metadata.</p>","variables":{},"functions":{"setters":{},"getters":{},"constructors":{},"operators":{},"methods":{"declare":{"name":"declare","qualifiedName":"unscripted/unscripted.declare","comment":"<p>Declares a <a>unscripted/unscripted.Script</a> from <a>unscripted/unscripted.declare.model</a>.</p>\n<p>The model is generally a closure of a method, which is annotated with\ncommand-line metadata.  The model can also be a class (see below).</p>\n<p>The method itself can be annotated as a <a>unscripted/unscripted.Command</a>.</p>\n<p>The method's parameters define the script's command-line parameters.\nNamed parameters with <a>dart-core.bool</a> type or <a>unscripted/unscripted.Flag</a> metadata represent command-line\nflags.  Other named parameters represent value-taking command-line options,\nand can accept <a>unscripted/unscripted.Option</a> metadata.  Required positional parameters are\nmapped to positional command-line parameters, and can use <a>unscripted/unscripted.Positional</a> metadata.\nOptional positional parameters are not allowed.  However, <a>unscripted/unscripted.Rest</a> metadata\ncan be placed on the last positional parameter to represent all remaining\npositional arguments passed to the script.</p>\n<p>Any value-taking argument (option, positional, rest) can have a \"parser\".\nThis is a function which is responsible for validating and/or transforming\nthe string value passed on the command-line before it is passed to the\nmethod.  Rest parsers are applied to each command-line value they receive.\nIf a parser throws an exception, it is <code>toString</code>ed and displayed to the\nuser\nParsers can be declared either via the <code>parser</code> field of the\nappropriate metadata (see above), or by giving the method parameter a type\nwhich has a static <code>parse</code> method that can be used as the parser.  For\nexample <code>int</code> parameters are parsed with <code>int.parse</code>.</p>\n<p>Sub-commands can be added to the script by creating a class with instance\nmethods annotated as <a>unscripted/unscripted.SubCommand</a>s.  The model returns an instance of this\nclass and documents this in it's return type.  Most commonly the model is\na constructor of this class.  But since dart does\n<a href=\"http://dartbug.com/10659\">not yet</a> have syntax for closurizing constructors,\nthe model can be a class literal, to indicate to that the unnamed\nconstructor of the class is the actual model.</p>\n<p>Help flags ('--help' / '-h') are automatically included.  If the script has\nsub-commands, a 'help' command is also included, which can be invoked bare,\n'help' as a synonym for '--help', or by specifying a sub-command e.g.\n'help sub-command'.</p>\n<p>When the returned script is [executed][Script.execute], if the user\nrequested help for, or incorrectly invoked, the command or a sub-command,\nthen the help text is displayed, along with any specific error.  Otherwise,\nthe command-line arguments are valid, and are injected into the\ncorresponding method parameters.  If the model has sub-commands, then if a\nsub-command was specified on the command-line, it is invoked with it's\ncorresponding command-line arguments, and so forth (recursively).  If a\nmodel has sub-commands, but no sub-command was specified, this is treated\nas an error, and the help text is displayed.</p>\n<p>Basic example:</p>\n<pre><code>main(arguments) =&gt; declare(greet).execute(arguments);\n\n// Optional command-line metadata:\n@Command(help: 'Outputs a greeting')\n@ArgExample('--salutation Welcome --exclaim Bob', help: 'enthusiastic')\ngreet(\n    @Rest(help: \"Name(s) to greet\")\n    List&lt;String&gt; who, // A rest parameter, must be last positional.\n    {String salutation : 'Hello', // An option, use `@Option(...)` for metadata.\n     bool exclaim : false}) { // A flag, use `@Flag(...)` for metadata.\n\n  print('$salutation ${who.join(' ')}${exclaim ? '!' : ''}');\n\n}\n</code></pre>\n<p>Sub-command example:</p>\n<pre><code>main(arguments) =&gt; declare(Server).execute(arguments);\n\nclass Server {\n\n  final String configPath;\n\n  @Command(help: 'Manages a server')\n  Server({this.configPath: 'config.xml'});\n\n  @SubCommand(help: 'Start the server')\n  start({bool clean}) {\n    print('''\nStarting the server.\nConfig path: $configPath''');\n  }\n\n  @SubCommand(help: 'Stop the server')\n  stop() {\n    print('Stopping the server.');\n  }\n\n}\n</code></pre>\n<p>Commands and SubCommands can also be annotated with <a>unscripted/unscripted.ArgExample</a>s, to\ndocument, in the help text, example arguments that they can receive.</p>\n<p>Parameter and command names which are camelCased are mapped to their\ndash-erized command-line equivalents.  For example, <code>fooBar</code> would map to\n<code>foo-bar</code>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unscripted/unscripted.Script","inner":[]}],"parameters":{"model":{"name":"model","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}}},"classes":{"class":[{"name":"ArgExample","qualifiedName":"unscripted/unscripted.ArgExample","preview":"<p>An annotation which gives example arguments that can be passed to a\n<a>unscripted/unscripted.Command</a> or <a>unscripted/unscripted.SubCommand</a>.</p>"},{"name":"Command","qualifiedName":"unscripted/unscripted.Command","preview":"<p>An annotation which marks a class as representing a script command.</p>"},{"name":"Completion","qualifiedName":"unscripted/unscripted.Completion","preview":"<p>A plugin to add tab completion to your script via a <code>completion</code> sub-command.</p>"},{"name":"Flag","qualifiedName":"unscripted/unscripted.Flag","preview":"<p>An annotation which marks named method parameters as command line flags.</p>"},{"name":"Input","qualifiedName":"unscripted/unscripted.Input","preview":"<p>Represents a script input, either <a>unscripted/dart-io.stdin</a> or a file.</p>"},{"name":"Option","qualifiedName":"unscripted/unscripted.Option","preview":"<p>An annotation which marks named method parameters as command line options.</p>"},{"name":"Output","qualifiedName":"unscripted/unscripted.Output","preview":"<p>Represents a script output, either <a>unscripted/dart-io.stdout</a> or a file.</p>"},{"name":"Positional","qualifiedName":"unscripted/unscripted.Positional","preview":"<p>An annotation which marks required positional parameters as\npositional command line parameters.</p>"},{"name":"Rest","qualifiedName":"unscripted/unscripted.Rest","preview":"<p>An annotation which marks the last positional parameter of a method\nas a rest argument.  If the parameter has a type annotation,\nit should be <code>List</code> or <code>List&lt;String&gt;</code>.</p>"},{"name":"Script","qualifiedName":"unscripted/unscripted.Script","preview":"<p>Represents a command-line script.</p>"},{"name":"SubCommand","qualifiedName":"unscripted/unscripted.SubCommand","preview":"<p>An annotation which marks an instance method of a <a>unscripted/unscripted.Command</a> as a\nsub-command.</p>"}],"typedef":{},"error":[]},"packageName":"unscripted","packageIntro":"<h1>unscripted</h1>\n<p><a href=\"https://drone.io/github.com/seaneagan/unscripted/latest\"><a href=\"https://drone.io/github.com/seaneagan/unscripted/status.png\"><img alt=\"Build Status\" src=\"https://drone.io/github.com/seaneagan/unscripted/status.png\"></img></a></a></p>\n<p><em>Define command-line interfaces using ordinary dart methods and classes.</em></p>\n<h2>Installation</h2>\n<p>Add the <a href=\"http://pub.dartlang.org/packages/unscripted\">unscripted package</a> to your pubspec.yaml dependencies:</p>\n<p><code>unscripted: '&gt;=0.4.0 &lt;0.5.0'</code></p>\n<h2>Usage</h2>\n<p>The following <a href=\"https://github.com/seaneagan/unscripted/tree/master/example/greet.dart\">greet.dart</a> script outputs a configurable greeting:</p>\n<pre class=\"dart\"><code>#!/usr/bin/env dart\n\nimport 'package:unscripted/unscripted.dart';\n\nmain(arguments) =&gt; declare(greet).execute(arguments);\n\n// All metadata annotations are optional.\n@Command(help: 'Print a configurable greeting', plugins: const [const Completion()])\n@ArgExample('--salutation Hi --enthusiasm 3 Bob', help: 'enthusiastic')\ngreet(\n    @Rest(help: 'Name(s) to greet.')\n    List&lt;String&gt; who, {\n      @Option(help: 'Alternate word to greet with e.g. \"Hi\".')\n      String salutation : 'Hello',\n      @Option(help: 'How many !\\'s to append.')\n      int enthusiasm : 0,\n      @Flag(abbr: 'l', help: 'Put names on separate lines.')\n      bool lineMode : false\n    }) {\n\n  print(salutation +\n        who.map((w) =&gt; (lineMode ? '\\n  ' : ' ') + w).join(',') +\n        '!' * enthusiasm);\n}\n</code></pre>\n<p>We can call this script as follows:</p>\n<pre class=\"shell\"><code>$ greet.dart Bob\nHello Bob\n$ greet.dart --salutation Hi --enthusiasm 3 -l Alice Bob\nHi\n  Alice,\n  Bob!!!\n</code></pre>\n<h2>Automatic --help</h2>\n<p>A <code>--help</code>/<code>-h</code> flag is automatically defined:</p>\n<pre class=\"shell\"><code>$ greet.dart --help\nPrint a configurable greeting\n\nUsage:\n\n  greet.dart [options] [WHO]...\n\nOptions:\n\n      --salutation         Alternate word to greet with e.g. \"Hi\".\n      --enthusiasm         How many !'s to append.\n  -l, --line-mode          Put names on separate lines.\n      --completion         Tab completion for this command.\n\n            [install]      Install completion script to .bashrc/.zshrc.\n            [print]        Print completion script to stdout.\n            [uninstall]    Uninstall completion script from .bashrc/.zshrc.\n\n  -h, --help               Print this usage information.\n\nExamples:\n\n  greet.dart --salutation Hi --enthusiasm 3 Bob # enthusiastic\n\n</code></pre>\n<h2>Sub-Commands</h2>\n<p>Sub-commands are represented as <code>SubCommand</code>-annotated instance methods of \nclasses, as seen in the following <a href=\"https://github.com/seaneagan/unscripted/tree/master/example/server.dart\">server.dart</a>:</p>\n<pre class=\"dart\"><code>#!/usr/bin/env dart\n\nimport 'dart:io';\n\nimport 'package:unscripted/unscripted.dart';\nimport 'package:path/path.dart' as path;\n\nmain(arguments) =&gt; declare(Server).execute(arguments);\n\nclass Server {\n\n  final String configPath;\n\n  @Command(\n      help: 'Manages a server',\n      plugins: const [const Completion()])\n  Server({this.configPath: 'config.xml'});\n\n  @SubCommand(help: 'Start the server')\n  start({bool clean}) {\n    print('''\nStarting the server.\nConfig path: $configPath''');\n  }\n\n  @SubCommand(help: 'Stop the server')\n  stop() {\n    print('Stopping the server.');\n  }\n\n}\n</code></pre>\n<p>We can call this script as follows:</p>\n<pre class=\"shell\"><code>$ server.dart start --config-path my-config.xml --clean\nStarting the server.\nConfig path: my-config.xml\n</code></pre>\n<p>Help is also available for sub-commands:</p>\n<pre class=\"shell\"><code>$ server.dart help\nAvailable commands:\n\n  start\n  help\n  stop\n\nUse \"server.dart help [command]\" for more information about a command.\n\n$ server.dart help stop\nStop the server\n\nUsage:\n\nserver.dart stop [options]\n\nOptions:\n\n-h, --help    Print this usage information.\n</code></pre>\n<h2>Parsers</h2>\n<p>Any value-taking argument (option, positional, rest) can have a \"parser\"\nresponsible for validating and transforming the string passed on the command \nline.  You can give an argument a parser simply by giving it a type (such as \n<code>int</code> or <code>DateTime</code>) which has a static <code>parse</code> method, or by specifying the \n<code>parser</code> named argument of the argument's metadata (<code>Option</code>, <code>Positional</code>, or \n<code>Rest</code>).</p>\n<h2>Plugins</h2>\n<p>Plugins allow you to mixin reusable chunks of cli-specific functionality \n(options/flags/commands) on top of your base interface.</p>\n<p>To add a plugin to your script, just add an instance of the associated plugin\nclass to the <code>plugins</code> named argument of your <code>@Command</code> annotation.  The \nfollowing plugins are available:</p>\n<h3>Tab Completion</h3>\n<p>Add bash/zsh <a href=\"http://en.wikipedia.org/wiki/Command-line_completion\">tab completion</a> to your script:</p>\n<pre class=\"dart\"><code>#!/usr/bin/env dart\n// ...\n@Command(plugins: const [const Completion()])\n</code></pre>\n<p>(Once <a href=\"http://dartbug.com/7874\">pub supports cli's</a>, the \"shebang\" line will no \nlonger be required.)</p>\n<p>If your script already has sub-commands, this will add a <code>completion</code> \nsub-command (similar to <a href=\"https://www.npmjs.org/doc/cli/npm-completion.html\">npm completion</a>), otherwise it adds a \n<code>--completion</code> option.  These can then be used as follows:</p>\n<pre class=\"shell\"><code># Try the tab-completion without permanently installing.\n. &lt;(greet.dart --completion print)\n. &lt;(server.dart completion print)\n\n# Install the completion script to .bashrc/.zshrc depending on current shell.\n# No-op if already installed.\ngreet.dart --completion install\nserver.dart completion install\n\n# Uninstall a previously installed completion script.\n# No-op if not installed.\ngreet.dart --completion uninstall\nserver.dart completion uninstall\n</code></pre>\n<p>Once installed, the user will be able to tab-complete all aspects of your cli,\nfor example:</p>\n<p><strong>Option/Flag names:</strong> Say your script is a dart method with a \n<code>longOptionName</code> named parameter.  This becomes <code>--long-option-name</code> in your \ncli, and once completion is installed, the user can type <code>--l[TAB]</code> and it will \nbe completed to <code>--long-option-name</code>.  It will also expand short options to their \nlong equivalents, e.g. <code>-vh[TAB]</code> becomes <code>--verbose --help</code>.</p>\n<p><strong>Commands:</strong> If your script is a dart class having a <code>@SubCommand() \nlongCommandName</code> method, that becomes a <code>long-command-name</code> sub-command in your \ncli, and the user can type <code>l[TAB]</code> and it will be completed to \n<code>long-command-name</code>.</p>\n<p><strong>Option/Positional/Rest values:</strong> The <code>allowed</code> named parameter of <code>Option</code> and \n<code>Positional</code> specifies the allowed values, and thus completions, for those \nparameters.  For example if you have \n<code>@Option(allowed: const ['red', 'yellow', 'green']) textColor</code>, and the user \ntypes <code>--text-color g[TAB]</code> this will become <code>--text-color green</code>.  In addition\nto <code>Iterable&lt;String&gt;</code>, allowed can also be a function of the form \n<code>Iterable&lt;String&gt; complete(String text)</code>, or it can even return a Future \n<code>Future&lt;Iterable&lt;String&gt;&gt; complete(String text)</code>.  For example if the \noption/positional represents a file name, you could emulate the builtin shell\nfile name completion by returning a list of filenames in the current directory.</p>\n<p>Tab completion is supported in <a href=\"http://en.wikipedia.org/wiki/Cygwin\">cygwin</a>, with one minor bug (#64).</p>\n<h3>Other Plugins</h3>\n<p>There are several other plugins planned, and also the ability to write your own\nis planned, see #62.</p>\n<h2>Demo</h2>\n<p><a href=\"https://github.com/seaneagan/unscripted/blob/master/example/cat.dart\">cat.dart</a> is a complete implementation of the *nix <code>cat</code> \nutility using unscripted.</p>"}