{"libraries":[{"packageName":"","name":"dart-core","qualifiedName":"dart-core","preview":"<p>Built-in types, collections,\nand other core functionality for every Dart program.</p>"},{"packageName":"unscripted","name":"unscripted","qualifiedName":"unscripted/unscripted","preview":"<p>Design command line interfaces through normal programming interfaces\nannotated with command line specific metadata.</p>","packageIntro":"<h1>unscripted</h1>\n<p><a href=\"https://drone.io/github.com/seaneagan/unscripted/latest\"><a href=\"https://drone.io/github.com/seaneagan/unscripted/status.png\"><img alt=\"Build Status\" src=\"https://drone.io/github.com/seaneagan/unscripted/status.png\"></img></a></a> | <a href=\"https://seaneagan.github.com/unscripted\">API docs</a></p>\n<p><em>Define command-line interfaces using ordinary dart methods and classes.</em></p>\n<h2>Installation</h2>\n<p>Add the <a href=\"http://pub.dartlang.org/packages/unscripted\">unscripted package</a> to your pubspec.yaml dependencies:</p>\n<p><code>unscripted: &gt;=0.4.0 &lt;0.5.0</code></p>\n<h2>Usage</h2>\n<p>The following <a href=\"https://github.com/seaneagan/unscripted/tree/master/example/greet.dart\">greet.dart</a> script outputs a configurable greeting:</p>\n<pre class=\"dart\"><code>#!/usr/bin/env dart\n\nimport 'package:unscripted/unscripted.dart';\n\nmain(arguments) =&gt; declare(greet).execute(arguments);\n\n// All metadata annotations are optional.\n@Command(help: 'Print a configurable greeting', plugins: const [const Completion()])\n@ArgExample('--salutation Hi --enthusiasm 3 Bob', help: 'enthusiastic')\ngreet(\n    @Rest(help: 'Name(s) to greet.')\n    List&lt;String&gt; who, {\n      @Option(help: 'Alternate word to greet with e.g. \"Hi\".')\n      String salutation : 'Hello',\n      @Option(help: 'How many !\\'s to append.')\n      int enthusiasm : 0,\n      @Flag(abbr: 'l', help: 'Put names on separate lines.')\n      bool lineMode : false\n    }) {\n\n  print(salutation +\n        who.map((w) =&gt; (lineMode ? '\\n  ' : ' ') + w).join(',') +\n        '!' * enthusiasm);\n}\n</code></pre>\n<p>We can call this script as follows:</p>\n<pre class=\"shell\"><code>$ greet Bob\nHello Bob\n$ greet --salutation Hi --enthusiasm 3 -l Alice Bob\nHi\n  Alice,\n  Bob!!!\n</code></pre>\n<h2>Automatic --help</h2>\n<p>A <code>--help</code>/<code>-h</code> flag is automatically defined:</p>\n<pre class=\"shell\"><code>$ greet.dart --help\nPrint a configurable greeting\n\nUsage:\n\n  greet.dart [options] [WHO]...\n\nOptions:\n\n      --salutation         Alternate word to greet with e.g. \"Hi\".\n      --enthusiasm         How many !'s to append.\n  -l, --line-mode          Put names on separate lines.\n      --completion         Tab completion for this command.\n\n            [install]      Install completion script to .bashrc/.zshrc.\n            [print]        Print completion script to stdout.\n            [uninstall]    Uninstall completion script from .bashrc/.zshrc.\n\n  -h, --help               Print this usage information.\n\nExamples:\n\n  greet.dart --salutation Hi --enthusiasm 3 Bob # enthusiastic\n\n</code></pre>\n<h2>Sub-Commands</h2>\n<p>Sub-commands are represented as <code>SubCommand</code>-annotated instance methods of \nclasses, as seen in the following <a href=\"https://github.com/seaneagan/unscripted/tree/master/example/server.dart\">server.dart</a>:</p>\n<pre class=\"dart\"><code>#!/usr/bin/env dart\n\nimport 'dart:io';\n\nimport 'package:unscripted/unscripted.dart';\nimport 'package:path/path.dart' as path;\n\nmain(arguments) =&gt; declare(Server).execute(arguments);\n\nclass Server {\n\n  final String configPath;\n\n  @Command(\n      help: 'Manages a server',\n      plugins: const [const Completion()])\n  Server({this.configPath: 'config.xml'});\n\n  @SubCommand(help: 'Start the server')\n  start({bool clean}) {\n    print('''\nStarting the server.\nConfig path: $configPath''');\n  }\n\n  @SubCommand(help: 'Stop the server')\n  stop() {\n    print('Stopping the server.');\n  }\n\n}\n</code></pre>\n<p>We can call this script as follows:</p>\n<pre class=\"shell\"><code>$ dart server.dart start --config-path my-config.xml --clean\nStarting the server.\nConfig path: my-config.xml\n</code></pre>\n<p>Help is also available for sub-commands:</p>\n<pre class=\"shell\"><code>$ dart server.dart help\nAvailable commands:\n\n  start\n  help\n  stop\n\nUse \"dart server.dart help [command]\" for more information about a command.\n\n$ dart server.dart help stop\nStop the server\n\nUsage:\n\ndart server.dart stop [options]\n\nOptions:\n\n-h, --help    Print this usage information.\n</code></pre>\n<h2>Parsers</h2>\n<p>Any value-taking argument (option, positional, rest) can have a \"parser\"\nresponsible for validating and transforming the string passed on the command \nline.  You can give an argument a parser simply by giving it a type (such as \n<code>int</code> or <code>DateTime</code>) which has a static <code>parse</code> method, or by specifying the \n<code>parser</code> named argument of the argument's metadata (<code>Option</code>, <code>Positional</code>, or \n<code>Rest</code>).</p>\n<h2>Plugins</h2>\n<p>Plugins allow you to mixin reusable chunks of cli-specific functionality \n(options/flags/commands) on top of your base interface.</p>\n<p>To add a plugin to your script, just add an instance of the associated plugin\nclass to the <code>plugins</code> named argument of your <code>@Command</code> annotation.  The \nfollowing plugins are available:</p>\n<h3>Tab Completion</h3>\n<p>Add bash/zsh <a href=\"http://en.wikipedia.org/wiki/Command-line_completion\">tab completion</a> to your script:</p>\n<pre class=\"dart\"><code>#!/usr/bin/env dart\n// ...\n@Command(plugins: const [const Completion()])\n</code></pre>\n<p>(Once <a href=\"http://dartbug.com/7874\">pub supports cli's</a>, the \"shebang\" line will no \nlonger be required.)</p>\n<p>If your script already has sub-commands, this will add a <code>completion</code> \nsub-command (similar to <a href=\"https://www.npmjs.org/doc/cli/npm-completion.html\">npm completion</a>), otherwise it adds a \n<code>--completion</code> option.  These can then be used as follows:</p>\n<pre class=\"shell\"><code># Try the tab-completion without permanently installing.\n. &lt;(greet.dart --completion print)\n. &lt;(server.dart completion print)\n\n# Install the completion script to .bashrc/.zshrc depending on current shell.\n# No-op if already installed.\ngreet.dart --completion install\nserver.dart completion install\n\n# Uninstall a previously installed completion script.\n# No-op if not installed.\ngreet.dart --completion uninstall\nserver.dart completion uninstall\n</code></pre>\n<p>Once installed, the user will be able to tab-complete all aspects of your cli,\nfor example:</p>\n<p><strong>Option/Flag names:</strong> Say your script is a dart method with a \n<code>longOptionName</code> named parameter.  This becomes <code>--long-option-name</code> in your \ncli, and once completion is installed, the user can type <code>--l[TAB]</code> and it will \nbe completed to <code>--long-option-name</code>.  It will also expand short options to their \nlong equivalents, e.g. <code>-vh[TAB]</code> becomes <code>--verbose --help</code>.</p>\n<p><strong>Commands:</strong> If your script is a dart class having a <code>@SubCommand() \nlongCommandName</code> method, that becomes a <code>long-command-name</code> sub-command in your \ncli, and the user can type <code>l[TAB]</code> and it will be completed to \n<code>long-command-name</code>.</p>\n<p><strong>Option/Positional/Rest values:</strong> The <code>allowed</code> named parameter of <code>Option</code> and \n<code>Positional</code> specifies the allowed values, and thus completions, for those \nparameters.  For example if you have \n<code>@Option(allowed: const ['red', 'yellow', 'green']) textColor</code>, and the user \ntypes <code>--text-color g[TAB]</code> this will become <code>--text-color green</code>.  In addition\nto <code>Iterable&lt;String&gt;</code>, allowed can also be a function of the form \n<code>Iterable&lt;String&gt; complete(String text)</code>, or it can even return a Future \n<code>Future&lt;Iterable&lt;String&gt;&gt; complete(String text)</code>.  For example if the \noption/positional represents a file name, you could emulate the builtin shell\nfile name completion by returning a list of filenames in the current directory.</p>\n<p>Tab completion is supported in <a href=\"http://en.wikipedia.org/wiki/Cygwin\">cygwin</a>, with one minor bug (#64).</p>\n<h3>Other Plugins</h3>\n<p>There are several other plugins planned, and also the ability to write your own\nis planned, see #62.</p>\n<h2>Demo</h2>\n<p><a href=\"https://github.com/seaneagan/unscripted/blob/master/example/cat.dart\">cat.dart</a> is a complete implementation of the *nix <code>cat</code> \nutility using unscripted.</p>"}],"introduction":"","filetype":"json","start-page":"unscripted"}